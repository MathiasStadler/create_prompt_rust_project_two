# Task: Create a Command-Line String Uppercase Converter in Rust

## Project Requirements

### Core Functionality

1. Create a command-line application in Rust that:
   - Accepts string input from users
   - Converts the input to uppercase
   - Displays the result

### Technical Requirements

1. Project Structure:
   - Create a new project in the current folder
   - Proper Rust project layout with Cargo
   - Separate library and binary crates
   - Organized test directory

2. Dependencies:
   - Use `clap` for CLI argument parsing
   - Implement error handling with `anyhow` and `thiserror`# create prompt rust project

## prompt

Generate a rust project with follow properties:

## Environment Setup

Create a program with the following function and observe the following conditions

- Function
  
  The program is to be started on the command line
  be started and request a character string as input and
  output this in capital letters on the command line.
  The program should then be terminated. The return value of the BASH command of the program should then be output

- Condition
  - Create a new project in the current folder
  - Create a single bash script with all the steps required to create the project
  - Iteratively check all output of the script and fix all errors
  - Iteratively check and delete all output of the project
  - OPERATING SYSTEM: Linux/Unix
  - IDE: Visual Studio Code
  - Language: Rust (latest stable version)
  - Follow the Rust standard formatting
  - Coverage tools: LLVM Coverage, Coverage Gutters extension
  - Check the installation command and follow it to install the extension
  - Paste everything into a Rust program file, do not use a bash script
  - Create a new project in the current folder
  - The test of the program should cover 100% of the Rust code
  - Write for each function, line, region, blo- All tests should cover 100% of the program code and branch a test case
  - Include comprehensive test cases
  - Implement error handling and it
  - Include comments for each lien

- Include comprehensive test cases
  - Implement error handling and correction
  - Add comments to documentation
  - Generate coverage reports
  - Create project documentation as Markdown with:
    - Project name and creation date (with time zone)
    - Environment details
    - System configuration
    - Build status
    - Test results
    - Coverage metrics
  - Test the output from any line on stdout
  - Also use assert_cmd
  - Test before the folder is not available
  - Inside this new folder, create a new Markdown file named project_path.md
  - And project_path.md follows these properties and fills in the current data with the hardware now in use
    - Name of the project
    - start date
    - Operating system used
    - Hardware used
    - Rust version used
  - Create a changelog.md file
  - Write documentation for all functions within the code
  - Use comments to make the code easier to read
  - Use a hashmap to store data
  - Create the project with cargo
  - Create a demo exampleCreate a program with the following function and observe the following conditions
  - Generate coverage reports
  - - Create project documentation as markdown with:
    - Project name and creation date (with timezone)
    - Environment details
    - System configuration
    - Build status
    - Test results
    - Coverage metrics
  - Test the output from any line to stdout
  - Use assert_cmd too
  - Test before the folder is not available
  - Inside this new folder create a new markdown file with the name project_path.md
  - And project_path.md follows these properties and fills in the current data with the hardware now in used
    - name of project
    - start date
    - used os
    - used hardware
    - used rust version
  - Generate a changelog.md file
  - Write for all function a documentation inside the code
  - Use comments to make code more readable
  - Use a hashmap to store data
  - Build the project with cargo
  - Create a demo exampleCreate a program with the following function and observe the following conditions
